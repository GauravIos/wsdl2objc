#summary Authentication options, handling defined server exceptions, SOAPSecurity, etc.
#labels Featured

= Authentication options =
As it is shown in the linked [http://code.google.com/p/wsdl2objc/wiki/UsageInstructions#Example example], you can set the username and password used in a case of a basic HTTP authentication required by the server. In this section we show all the authentication options that are currently supported.

== The authentication properties dictionary ==
All the authentication options can be accessed by setting appropriate flags in the *authenticationProperties* dictionary of the *binding*.

As top level keys, you should provide the identifiers of the authentication methods you would like to handle. For each key you should provide a new dictionary with the appropriate options set. Currently only the following identifiers are accepted:
  * NSURLAuthenticationMethodHTTPBasic
  * NSURLAuthenticationMethodClientCertificate
  * NSURLAuthenticationMethodServerTrust 

=== NSURLAuthenticationMethodHTTPBasic ===
This method should be used in a case of a basic HTTP authentication (username/password). The dictionary provided under this key should contain the following keys:
  * kClientUsername *(mandatory)*
  * kClientPassword *(mandatory)*
  * kNSURLCredentialPersistence

If kNSURLCredentialPersistence key is set, it should contain the NSNumber representation of the NSURLCredentialPersistance enum. That is, the NSNumber representation to one of:
  * NSURLCredentialPersistenceNone
  * NSURLCredentialPersistenceForSession
  * NSURLCredentialPersistencePermanent

If not set NSURLCredentialPersistenceForSession is used by default.
----
{{{
       ...
       NSNumber *persistance = [NSNumber numberWithUnsignedInteger:NSURLCredentialPersistenceForSession];
       NSDictionary *credentials = [NSDictionary dictionaryWithObjectsAndKeys:
                                     @"my username", kClientUsername,
                                     @"my password", kClientPassword,
                                     persistance, kNSURLCredentialPersistence,
                                     nil];
       NSDictionary *authProperties = [NSDictionary dictionaryWithObject:credentials 
                                                                   forKey:NSURLAuthenticationMethodHTTPBasic];
        
       binding.authenticationProperties = authProperties;        
       ...
}}}
----

=== NSURLAuthenticationMethodClientCertificate ===
If you need a more advanced client authentication method, than the basic HTTP one, you can use the client certificate authentication method.

*NOTE* that on *Mac OS X*, the client certificate that should be used is configured by the user via the *Keychain Access* application and is sent automatically by the system. So you should set this method *only* if you need a client certificate authentication in your *iPhone* application.

The following keys are accepted:
  * kClientIdentity *(mandatory)*
  * kClientCertificates *(mandatory)*
  * kNSURLCredentialPersistence

It is out of scope to describe how you can get the identity and the certificate of the client, but we shell mention that in order to do that you would need to somehow bundle the PKCS12 keystore, containing the stuff, together with the application. Once you have the bytes of the PKCS12 file and it's password you can do something like:

----
{{{
- (NSArray *)importPKCS12
{
    static NSArray *pkcs12 = nil;
    if (!pkcs12) {
        NSData *pkcsData = [self dataPKCS12];
        NSString *password = [self passwordPKCS12];
        
        OSStatus sanityChesk = SecPKCS12Import((CFDataRef)pkcsData, 
                                               (CFDictionaryRef)[NSDictionary dictionaryWithObject:password 
                                                                                            forKey:(id)kSecImportExportPassphrase], 
                                               (CFArrayRef *)&pkcs12);
        // check that sanityChesk == noErr
        [pkcs12 retain];
    }
    
    return pkcs12;
}

- (SecIdentityRef)clientIdentity
{
    SecIdentityRef identity = (SecIdentityRef)[[[self importPKCS12] objectAtIndex:0]
                                               objectForKey:(id)kSecImportItemIdentity];
    return identity;
}

- (NSArray *)clientCertificates
{
    NSArray *certs = [[[self importPKCS12] objectAtIndex:0]
                      objectForKey:(id)kSecImportItemCertChain];
    return certs;
}
}}}

And then include the identity and the certificates into the authentication properties of the bundle
{{{
       ...
       NSNumber *persistance = [NSNumber numberWithUnsignedInteger:NSURLCredentialPersistenceForSession];
       NSDictionary *credentials = [NSDictionary dictionaryWithObjectsAndKeys:
                                     (id)[self clientIdentity], kClientIdentity,
                                     [self clientCertificates], kClientCertificates,
                                     persistance, kNSURLCredentialPersistence,
                                     nil];
       NSDictionary *authProperties = [NSDictionary dictionaryWithObject:credentials 
                                                                   forKey:NSURLAuthenticationMethodClientCertificate];
        
       binding.authenticationProperties = authProperties;        
       ...
}}}
----
It's worth mentioning that some of the security API methods are missing on MAC OS X, so the above code *will not work* on simulator (device only).

=== NSURLAuthenticationMethodServerTrust ===
The last authentication method supported should be used in a case of a self-signed server certificates. As for the previous method, it should be used *only for iPhone* applications as on MAC OS X the user can set the proper trust settings using Keychain Access. 

The dictionary provided under this key should contain the following keys:
  * kServerAnchorCertificates *(mandatory)*
  * kServerAnchorsOnly *(mandatory)*
  * kValidateResult *(mandatory)*

The first key should hold an array of all anchor certificates which you would like the server certificate to be validated against. Usually this would be the self-signed CA that issued the certificate. Again, you would need it's bytes into the application.

The second key should hold a boolean value, represented as NSNumber, stating wether the system should validate the server certificate against the provided anchors only (YES), or it should also include the system root certificates (NO). Usually you would like to pass YES here.

Finally the last key should hold a NSValue representation of your validation result callback. The callback should accept one argument (NSNumber representation of the validation result), and should return YES if the result is acceptable, or NO otherwise.<br>
The possible validation results are:
  * kSecTrustResultInvalid
  * kSecTrustResultProceed
  * kSecTrustResultConfirm
  * kSecTrustResultDeny
  * kSecTrustResultUnspecified
  * kSecTrustResultRecoverableTrustFailure
  * kSecTrustResultFatalTrustFailure
  * kSecTrustResultOtherError

All of this codes are provided to handle different situations where the user has the opportunity to choose wether to trust some certificate or not (e.g. when accessing via web browser). In general you should return YES for the *Proceed*, *Confirm* and *Unspecified* cases, and NO for all of the rest. For more info please check the iPhone SDK documentation.
----
{{{
- (NSArray *)serverAnchors 
{
    static NSArray *anchors = nil;
    if (!anchors) {
        NSData *caData = [self dataCA];
        SecCertificateRef caRef = SecCertificateCreateWithData(kCFAllocatorDefault, (CFDataRef) caData);
        
        anchors = [[NSArray arrayWithObject:(id)caRef] retain];
        CFRelease(caRef);
    }
    
    return anchors;
}

- (BOOL)trustCertificate:(NSNumber *)res
{
    int result = [res intValue];
    if (result == kSecTrustResultProceed
        || result == kSecTrustResultConfirm
        || result == kSecTrustResultUnspecified) {
        return YES;
    }
    
    return NO;
}
}}}

{{{
       ...
       NSValue *callback = [NSValue valueWithPointer:@selector(trustCertificate:)];       
       NSDictionary *credentials = [NSDictionary dictionaryWithObjectsAndKeys:
                                     (id)[self serverAnchors], kServerAnchorCertificates,
                                     [NSNumber numberWithBool:YES], kServerAnchorsOnly,
                                     callback, kValidateResult,
                                     nil];
       NSDictionary *authProperties = [NSDictionary dictionaryWithObject:credentials 
                                                                   NSURLAuthenticationMethodServerTrust];
        
       binding.authenticationProperties = authProperties;        

       ...
}}}

= Handling defined faults =
TODO

= SOAPSecurity =
TODO
 