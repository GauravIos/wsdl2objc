#summary Authentication options, handling defined server exceptions, SOAPSecurity, etc.

= Authentication options =
As it is shown in the linked [http://code.google.com/p/wsdl2objc/wiki/UsageInstructions#Example example], you can set the username and password used in a case of a basic HTTP authentication required by the server. In this section we show all the authentication options that are currently supported.

== The authentication properties dictionary ==
All the authentication options can be accessed by setting appropriate flags in the *authenticationProperties* dictionary of the *binding*.

As top level keys, you should provide the identifiers of the authentication methods you would like to handle. For each key you should provide a new dictionary with the appropriate options set. Currently only the following identifiers are accepted:
  * NSURLAuthenticationMethodHTTPBasic
  * NSURLAuthenticationMethodClientCertificate
  * NSURLAuthenticationMethodServerTrust 

=== NSURLAuthenticationMethodHTTPBasic ===
This method should be used in a case of a basic HTTP authentication (username/password). The dictionary provided under this key should contain the following keys:
  * kClientUsername *(mandatory)*
  * kClientPassword *(mandatory)*
  * kNSURLCredentialPersistence

If kNSURLCredentialPersistence key is set, it should contain the NSNumber representation of the NSURLCredentialPersistance enum. That is, the NSNumber representation to one of:
  * NSURLCredentialPersistenceNone
  * NSURLCredentialPersistenceForSession
  * NSURLCredentialPersistencePermanent

If not set NSURLCredentialPersistenceForSession is used by default.
----
{{{
       NSNumber *persistance = [NSNumber numberWithUnsignedInteger:NSURLCredentialPersistenceForSession];
       NSDictionary *credentials = [NSDictionary dictionaryWithObjectsAndKeys:
                                     @"my username", kClientUsername,
                                     @"my password", kClientPassword,
                                     persistance, kNSURLCredentialPersistence,
                                     nil];
       NSDictionary *authProperties = [NSDictionary dictionaryWithObject:credentials 
                                                                   forKey:NSURLAuthenticationMethodHTTPBasic];
        
       binding.authenticationProperties = authProperties;        
}}}
----

=== NSURLAuthenticationMethodClientCertificate ===
If you need a more advanced client authentication method, than the basic HTTP one, you can use the client certificate authentication method.

*NOTE* that on *Mac OS X*, the client certificate that should be used is configured by the user via the *Keychain Access* application and is sent automatically by the system. So you should set this method *only* if you need a client certificate authentication in your *iPhone* application.

The following keys are accepted:
  * kClientIdentity *(mandatory)*
  * kClientCertificates *(mandatory)*
  * kNSURLCredentialPersistence

It is out of scope to describe how you can get the identity and the certificate of the client, but we shell mention that in order to do that you would need to somehow bundle the PKCS12 keystore, containing the stuff, together with the application. Once you have the bytes of the PKCS12 file and it's password you can do something like:

----
{{{
- (NSArray *)importPKCS12
{
    static NSArray *pkcs12 = nil;
    if (!pkcs12) {
        NSData *pkcsData = [self dataPKCS12];
        NSString *password = [self passwordPKCS12];
        
        OSStatus sanityChesk = SecPKCS12Import((CFDataRef)pkcsData, 
                                               (CFDictionaryRef)[NSDictionary dictionaryWithObject:password 
                                                                                            forKey:(id)kSecImportExportPassphrase], 
                                               (CFArrayRef *)&pkcs12);
        // check that sanityChesk == noErr
        [pkcs12 retain];
    }
    
    return pkcs12;
}

- (SecIdentityRef)clientIdentity
{
    SecIdentityRef identity = (SecIdentityRef)[[[self importPKCS12] objectAtIndex:0]
                                               objectForKey:(id)kSecImportItemIdentity];
    return identity;
}

- (NSArray *)clientCertificates
{
    NSArray *certs = [[[self importPKCS12] objectAtIndex:0]
                      objectForKey:(id)kSecImportItemCertChain];
    return certs;
}
}}}

And then include the identity and the certificates into the authentication properties of the bundle
{{{

       NSNumber *persistance = [NSNumber numberWithUnsignedInteger:NSURLCredentialPersistenceForSession];
       NSDictionary *credentials = [NSDictionary dictionaryWithObjectsAndKeys:
                                     (id)[self clientIdentity], kClientIdentity,
                                     [self clientCertificates], kClientCertificates,
                                     persistance, kNSURLCredentialPersistence,
                                     nil];
       NSDictionary *authProperties = [NSDictionary dictionaryWithObject:credentials 
                                                                   forKey:NSURLAuthenticationMethodClientCertificate];
        
       binding.authenticationProperties = authProperties;        
}}}
----

=== NSURLAuthenticationMethodServerTrust ===
*TODO*