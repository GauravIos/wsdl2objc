#summary Authentication options, handling defined server exceptions, SOAPSecurity, etc.
#labels Featured

This page covers some of the more advanced options, not available in versions 0.6 and 0.7-pre1.<br>

= Authentication options =
In order to provide proper support for advanced authentication, the SSL authentication logic has been removed from the generated code, and delegated to a user-defined delegate. The delegate will have to implement the *[http://code.google.com/p/wsdl2objc/source/browse/trunk/Templates/WSDL2ObjC%20Standard%20Additions/USAdditions_H.template SSLCredentialsManaging]* protocol, defined in the generated sources.

== Basic Authentication ==
The generated code, provides a simple [http://code.google.com/p/wsdl2objc/source/browse/trunk/Templates/WSDL2ObjC%20Standard%20Additions/USAdditions_H.template implementation] of the protocol, which can be used for basic SSL authentication.

To use it, you just need to instantiate the delegate with an username and password, and set the *sslManager* property of the binding:
{{{
...
BasicSSLCredentialsManager *manager = 
    [BasicSSLCredentialsManager managerWithUsername:u.text andPassword:p.text];
       
binding.sslManager = manager;        
...
}}}

You can check the implementation of the *BasicSSLCredentialsManager*  [http://code.google.com/p/wsdl2objc/source/browse/trunk/Templates/WSDL2ObjC%20Standard%20Additions/USAdditions_M.template here].

== Self-signed server certificate ==
If your application connects to a server which has a self-signed certificate, then simply letting the system to validate the server will not do the job, as the received certificate would come from an unknown certificate authority.<br>
In this case, you need to tell the system which certificate authorities you are expecting, and handle the validation process manually. In order to do this you need a couple of things:
 * The root certificate that have signed the server side certificate. <br> One way to get this in your code is by making it part of your application binary, and then generating a NSData instance out of it:
{{{
- (NSData *)dataCA
{
    uint8_t bytes[] = {CA_BYTES};
    return [NSData dataWithBytes:bytes length:CA_LENGTH];
}
}}}
 * A NSArray holding the references of all the root certificates you need to support (in this case only one):
{{{
- (NSArray *) serverAnchors
{
    static NSArray *anchors = nil;
    if (!anchors) {
        NSData *caData = [self dataCA];
        SecCertificateRef caRef = SecCertificateCreateWithData(kCFAllocatorDefault, (CFDataRef) caData);
      
        anchors = [[NSArray arrayWithObjects:(id)caRef,  nil] retain];
        
        if (caRef) {
            CFRelease(caRef);   
        }
    }
    
    return anchors;
}
}}}

 * A proper *SSLCredentialsManaging* protocol implementation. <br> In the code below we give only the most important part of the implementation, which basically tell the system that we want to handle the authentication manually, and then validates the server certificate received:
{{{
- (BOOL)canAuthenticateForAuthenticationMethod:(NSString *)authMethod
{
    return [authMethod isEqualToString:NSURLAuthenticationMethodServerTrust];
}
}}}
{{{
- (BOOL)validateResult:(SecTrustResultType)res
{
    if ((res == kSecTrustResultProceed)                 // trusted certificate
        || ((res == kSecTrustResultConfirm)             // valid but user should be asked for confirmation
            || (res == kSecTrustResultUnspecified)      // valid but user have not specified wheter to trust
            || (res == kSecTrustResultDeny)             // valid but user does not trusts this certificate
            )
        )
    {
        return YES;
    } 
    
    return NO;
}

- (BOOL)authenticateForChallenge:(NSURLAuthenticationChallenge *)challenge
{
    if ([challenge previousFailureCount] > 0) {        
        return NO;
    }
    
    NSURLCredential *newCredential = nil;
    NSURLProtectionSpace *protectionSpace = [challenge protectionSpace];
    SecurityCenter *securityCenter = [SecurityCenter sharedInstance];
    
    // server authentication - NSURLAuthenticationMethodServerTrust
    if ([protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {
        SecTrustRef trust = [protectionSpace serverTrust];
        NSArray *anchors = [securityCenter serverAnchors];
        SecTrustSetAnchorCertificates(trust, (CFArrayRef)anchors);
        SecTrustSetAnchorCertificatesOnly(trust, YES);
        
        
        SecTrustResultType res = kSecTrustResultInvalid;
        OSStatus sanityChesk = SecTrustEvaluate(trust, &res);
               
        if ((sanityChesk == noErr) 
            && [self validateResult:res]) {
            
            newCredential = [NSURLCredential credentialForTrust:trust];
            [[challenge sender] useCredential:newCredential forAuthenticationChallenge:challenge];
            
            return YES;
        }
        
        return NO;
    }
    
    [NSException raise:@"Authentication method not supported" format:@"%@ not supported.", [protectionSpace authenticationMethod]];
    return NO;
}
}}}

== Client-side certificate authentication ==
Some services (e.g. eBanking) are intended to be consumed only by a defined set of client applications. In this case you might need to use 2-way SSL, which asks the client application to authenticate with proper certificate. <br> To do this, you would need the following:
 * NSData representation of a PKCS12 key store, holding the certificate and the private key for the client. <br> One way to do this is to integrate the key store as part of the application's byte code.
{{{
- (NSData *)dataPKCS12
{
    uint8_t bytes[] = {PKCS12_BYTES};
    return [NSData dataWithBytes:bytes length:PKCS12_LENGTH];
}
}}}
 * NSArray, in this case named *keystores*, which holds all the key/certificate entries in the key store, each represented by a single NSDictionary instance:
{{{
- (void)importPKCS12
{
    if (!keystores) {
        NSData *pkcsData = [self dataPKCS12];
        NSString *password = [self passwordPKCS12];
        
        OSStatus sanityChesk = SecPKCS12Import((CFDataRef)pkcsData, 
                                               (CFDictionaryRef)[NSDictionary dictionaryWithObject:password 
                                                                                            forKey:(id)kSecImportExportPassphrase], 
                                               (CFArrayRef *)&keystores);
        CHECK_CONDITION1(sanityChesk == noErr, @"Error while importing pkcs12 [%d]", sanityChesk);
        [keystores retain];
    }
}
}}}
 * Logic to extract the *identity* and *certificates* for the client. <br> In this example the *clientKeyStore* variable points to one of the entries in the *keystores* variable mentioned above:
{{{
- (SecIdentityRef)clientIdentity
{
    return (SecIdentityRef)[clientKeyStore objectForKey:(id)kSecImportItemIdentity];
}

- (NSArray *)clientCertificates
{
    return [clientKeyStore objectForKey:(id)kSecImportItemCertChain];
}
}}}
 * A proper *SSLCredentialsManaging* protocol implementation. <br> In the code below we give only the most important part of the implementation, which basically tell the system that we want to handle the authentication manually, and then authenticates the client with a certificate:
{{{
- (BOOL)canAuthenticateForAuthenticationMethod:(NSString *)authMethod
{
    return [authMethod isEqualToString:NSURLAuthenticationMethodClientCertificate];
}
}}}
{{{
- (BOOL)authenticateForChallenge:(NSURLAuthenticationChallenge *)challenge
{
    if ([challenge previousFailureCount] > 0) {        
        return NO;
    }
    
    NSURLCredential *newCredential = nil;
    NSURLProtectionSpace *protectionSpace = [challenge protectionSpace];
    SecurityCenter *securityCenter = [SecurityCenter sharedInstance];
    
    // client authentication - NSURLAuthenticationMethodClientCertificate
    if ([protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodClientCertificate]) {
       
        NSArray *acceptedIssuers = [protectionSpace distinguishedNames];
        [securityCenter setIssuerDistinguishedNames:acceptedIssuers];
        
        SecIdentityRef identity = (SecIdentityRef)[securityCenter clientIdentity];
        NSArray *certs = [securityCenter clientCertificates];
        
        if (identity && certs) {
            newCredential = [NSURLCredential credentialWithIdentity:identity
                                                       certificates:certs
                                                        persistence:NSURLCredentialPersistenceNone];
            [[challenge sender] useCredential:newCredential forAuthenticationChallenge:challenge];
            
            return YES;
        }
        
        return NO;
    }
    
    [NSException raise:@"Authentication method not supported" format:@"%@ not supported.", [protectionSpace authenticationMethod]];
    return NO;
}
}}}

= Handling defined faults =
TODO

= SOAPSecurity =
*SOAP signing is currently disabled due to issue 139:*

TODO
 